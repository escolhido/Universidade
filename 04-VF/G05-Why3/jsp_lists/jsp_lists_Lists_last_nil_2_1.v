(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require list.List.
Require list.Length.
Require int.Int.
Require list.Mem.
Require list.Append.
Require list.Reverse.

(* Why3 assumption *)
Fixpoint infix_plpl {a:Type} {a_WT:WhyType a} (l1:(list a))
  (l2:(list a)) {struct l1}: (list a) :=
  match l1 with
  | Init.Datatypes.nil => l2
  | (Init.Datatypes.cons x1 r1) => (Init.Datatypes.cons x1 (infix_plpl r1
      l2))
  end.

Axiom app_nil : forall {a:Type} {a_WT:WhyType a}, forall (l:(list a)),
  ((infix_plpl l Init.Datatypes.nil) = l).

(* Why3 assumption *)
Fixpoint length {a:Type} {a_WT:WhyType a} (l:(list a)) {struct l}: Z :=
  match l with
  | Init.Datatypes.nil => 0%Z
  | (Init.Datatypes.cons _ r) => (1%Z + (length r))%Z
  end.

Axiom aux_length : forall {a:Type} {a_WT:WhyType a}, forall (x:a)
  (l:(list a)), ((length (Init.Datatypes.cons x l)) = (1%Z + (length l))%Z).

Axiom app_length : forall {a:Type} {a_WT:WhyType a}, forall (l1:(list a))
  (l2:(list a)), ((length (infix_plpl l1
  l2)) = ((length l1) + (length l2))%Z).

(* Why3 assumption *)
Fixpoint snoc {a:Type} {a_WT:WhyType a} (x:a)
  (l:(list a)) {struct l}: (list a) :=
  match l with
  | Init.Datatypes.nil => (Init.Datatypes.cons x Init.Datatypes.nil)
  | (Init.Datatypes.cons h t) => (Init.Datatypes.cons h (snoc x t))
  end.

Axiom snoc_len : forall {a:Type} {a_WT:WhyType a}, forall (x:a) (l:(list a)),
  ((length (snoc x l)) = (1%Z + (length l))%Z).

Axiom snoc_app : forall {a:Type} {a_WT:WhyType a}, forall (x:a) (l:(list a)),
  ((snoc x l) = (infix_plpl l (Init.Datatypes.cons x Init.Datatypes.nil))).

Axiom mem_app : forall {a:Type} {a_WT:WhyType a}, forall (x:a) (l1:(list a))
  (l2:(list a)), (list.Mem.mem x (infix_plpl l1 l2)) -> ((list.Mem.mem x
  l1) \/ (list.Mem.mem x l2)).

Axiom rev_aux : forall {a:Type} {a_WT:WhyType a}, forall (x:a) (l:(list a)),
  ((Lists.List.rev (infix_plpl l
  (Init.Datatypes.cons x Init.Datatypes.nil))) = (Init.Datatypes.cons x (Lists.List.rev l))).

Axiom rev_rev : forall {a:Type} {a_WT:WhyType a}, forall (l:(list a)),
  ((Lists.List.rev (Lists.List.rev l)) = l).

(* Why3 assumption *)
Inductive last {a:Type} {a_WT:WhyType a}: a -> (list a) -> Prop :=
  | Last_one : forall (x:a), (last x
      (Init.Datatypes.cons x Init.Datatypes.nil))
  | Last_two : forall (x:a) (y:a) (l:(list a)), (last x l) -> (last x
      (Init.Datatypes.cons y l)).

Axiom last_nil : forall {a:Type} {a_WT:WhyType a}, forall (x:a), ~ (last x
  Init.Datatypes.nil).

Axiom last_nil_aux : forall {a:Type} {a_WT:WhyType a}, forall (x:a)
  (l:(list a)), (last x l) -> ~ (l = Init.Datatypes.nil).

(* Why3 goal *)
Theorem last_nil_2 : forall {a:Type} {a_WT:WhyType a}, forall (x:a), ~ (last
  x Init.Datatypes.nil).
(* Why3 intros a a_WT x. *)
intros a a_WT x.

Qed.

